#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# script to generate a graph made of ReFRESCO's module, links between them represent USE statements
# License MIT

import os
import sys
import glob
import argparse
from itertools import chain
import re
import networkx as nx
from pyvis.network import Network

# import seaborn as sns
# current_palette = sns.color_palette('pastel')
# hex_palette = current_palette.as_hex()
hex_palette = ['#fab0e4', '#ffb482', '#8de5a1', '#ff9f9b', '#d0bbff', '#debb9b', '#cfcfcf', '#fffea3', '#b9f2f0', '#a1c9f4']

# size of the plot
size_factor = 50


##########################
# parsing arguments
##########################

parser = argparse.ArgumentParser(description='Generates module graph for ReFRESCO.')

parser.add_argument('path', type=str, nargs='?', help='path to ReFRESCO Code/src directory, default being $REFRESCO_CODE_DIR/src', default=None)
parser.add_argument('--dest', type=str, help='path to the html output file', default="refresco-module-graph.html")
parser.add_argument('--automatic', dest='automatic', help='displays autogenerated modules (from the /automatic folder)', action='store_true')
parser.add_argument('--build-dir', type=str, help='path to ReFRESCO build directory when using CMake (used to detect autogenerated modules)', default=None)
args = parser.parse_args()

automatic = args.automatic 
if os.path.isdir(args.dest):
    HTML_export = os.path.join(args.dest, "refresco-module-graph.html")
else:
    HTML_export = args.dest

if args.path:
    sourcePath = args.path
else:
    sourcePath = os.path.join(os.environ['REFRESCO_CODE_DIR'],"src")

if args.build_dir:
    automaticPath = os.path.join(args.build_dir, "Code", "src")
else:
    automaticPath = os.path.join(sourcePath, "automatic")

print("source folder:    {}".format(sourcePath))
print("automatic folder: {}".format(automaticPath))



##########################
# read .F90 files
##########################

USElinkList = []
moduleLevelList = []


if automatic:
    automaticModule = []
    fileList = chain(glob.iglob(os.path.join(sourcePath,"*F90")), glob.iglob(os.path.join(automaticPath, "*F90")))
else:
    automaticModule = [ os.path.basename(filename)[:-4] for filename in glob.glob(os.path.join(automaticPath, "*F90")) ]
    fileList = glob.iglob(os.path.join(sourcePath, "*F90"))

def toDiscard(edge):
    return edge in automaticModule

for filename in fileList:
    noLevel = True
    module = os.path.basename(filename)[:-4]
    with open(filename, 'r') as f:
        for line in f.readlines():
            if line.startswith("!") and noLevel:
                elem = re.search("^!.*Level:\ *(.*)$", line)
                if elem:
                    level = elem[1].split('/')[0].lower()
                    if not ('?' in level or level == '-'):
                        moduleLevelList.append([module, level])
                        noLevel = False

            if line.lower().startswith("use "):
                elem = re.search("^(use|USE)\ +([a-zA-Z0-9_]*).*", line)
                if elem and not toDiscard(module) and not toDiscard(elem[2]):
                    USElinkList.append([module, elem[2]])

##########################
# build nx graph
##########################
G = nx.DiGraph()
for edge in USElinkList:
    G.add_edges_from([edge])


cyclic = list(nx.simple_cycles(G))
if cyclic:
    print("Circular import, exiting", cyclic)
    sys.exit(1)
else:
    print("No circular import")

##########################
# Compute node positions
##########################

stageDict = {}
for module in G.nodes:
    stageDict[module] = 0

prevStageDict = {}
while stageDict != prevStageDict:
    prevStageDict = stageDict.copy()
    for module in G.nodes:
        stage = stageDict[module]
        maxStage = -1
        for child in G.successors(module):
            if stageDict[child] > maxStage:
                maxStage = stageDict[child]
        stageDict[module] = maxStage +1

stageList = [ [] for _ in range(max(stageDict.values())+1) ]

for key, value in stageDict.items():
        stageList[value].append(key)

position = {}

for i, stage in enumerate(stageList):
    for j, module in enumerate(stage):
        position[module] = ((j+1)*30/(len(stage)+1),i)



##########################
# Assign levels
##########################

G_pyvis = Network(height="100%", width="100%", directed=True)
levelList = sorted(list(set([ elem[1] for elem in moduleLevelList ])))

level_color_dict = {}
for i, level in enumerate(levelList):
    level_color_dict[level] = hex_palette[(i)%len(hex_palette)]

moduleLevelDict = {}
for module, level in moduleLevelList:
    moduleLevelDict[module] = level

def get_color(module):
    if module in moduleLevelDict:
        return level_color_dict[moduleLevelDict[module]]
    else:
        return '#ffffff'

# generate level nodes
for i, level in enumerate(levelList):
    G_pyvis.add_node(level, 
                     level,
                     title=level,
                     x=-5*size_factor, 
                     y=-2*size_factor*i,
                     shape='ellipse',
                     color=level_color_dict[level])


##########################
# Display main graph
##########################
moduleList  = [item for sublist in USElinkList for item in sublist]
moduleList = list(set(moduleList))

for module in moduleList:
    G_pyvis.add_node(module,
                     module,
                     title=module,
                     shape="ellipse",
                     x=size_factor*position[module][0],
                     y=-size_factor*position[module][1],
                     physics=False,
                     color=get_color(module))

for edge in USElinkList:
    G_pyvis.add_edge(edge[0], edge[1])


try:
    G_pyvis.set_options("""
  var options = {
                "configure": {
                        "enabled": false
                },
                "edges": {
                        "color": {
                                "color": "rgba(55,132,233,1)",
                                "highlight": "rgba(244,17,31,1)",
                                "inherit": false
                        },
                        "smooth": {
                                "enabled": true,
                                "type": "continuous"
                        }
                },
                "interaction": {
                        "dragNodes": true,
                        "hideEdgesOnDrag": false,
                        "hideNodesOnDrag": false
                },
                "physics": {
                        "enabled": true
                }
        }""")
except AttributeError:
    import warnings
    warnings.warn("Use the lastest version of pyvis to have the proper output")



G_pyvis.write_html(HTML_export)
print("{} generated".format(HTML_export))

